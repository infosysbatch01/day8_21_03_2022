* class and object
* Features of OOP:-
  ** Encapsulation===> Encapsulating methods and variables within a class and using access modifiers 
     to decide which member to be kept exposed outside the class and which members to hide
  ** Inheritance ====> We dont have multiple Inehritance in Java through classes but we can achieve
     it through interfaces
  ** Polymorphism ===> Method overloading and Method overriding
  ** Abstraction ====> ( Abstract classes and Interfaces )
------------------------------------------------------------------------------------------------
Modifiers
* static===>
  static can be used for inner classes, with variables of a class
  and with methods
* final====> final can be used with class,methods and variables
* abstract=> abstract can be used with methods and class/

  public class Revise1 {
   public static void main(String args[]) {
     static int i=10;
     System.out.println(i);
   }
 }

1) Compilation error ( a local member cannot be declared as static).
   static should be used for the member of a class. So method, inner class and variables(not the local) can be declared as static)
2) No compilation error


  public class Revise2 {
   public static void main(String args[]) {
     final int i=10;
     System.out.println(i);
   }
 }

1) Compilation error
2) Ouput is shown
Ans 2. Local variables can be declared as final.

-------------------------------------------------------------------------------------------

-------------------------------------------------------------
* We cannot create an object of abstract class.
  Because we have some of the methods as abstract which are
  not implemented.
* Abstract class can be without abstract method.
* Abstract class are designed for the purpose of Inheritance. 
* The subclass should override all the abstract methods of the abstract class.
* If the subclass is not overriding all the abstract methods, the subclass itself needs
  to be declared as an abstract class.

  public final abstract class Demo{}
* A class cannot be declared as final and abstract both because
  abstract class needs to be inherited and final class we
  don't inherit.
* We design abstract class when the base class needs to 
  have some methods for which the implementation will be different in the subclass.


package demo_trainer_21_03_2022;

public abstract class Base {
	private int num;
	
   public Base()
   {
	   num=10;
	   System.out.println("I am the constructor");
   }
  
   abstract void method();
}


package demo_trainer_21_03_2022;

public class Derived extends Base {

	
	public Derived()
	{
		System.out.println("I am the derived class parameterless constructor");
	}
	
	@Override
	void method() {
		System.out.println("I am the implemented method");
		
	}

	
}

package demo_trainer_21_03_2022;

public abstract class Base {
	private int num;
	
   public Base()
   {
	   num=10;
	   System.out.println("I am the constructor");
   }
  
   abstract void method();
}






-----------------------------  

package infosys.demo.withoutabstract;

   public class Triangle {
     private int x;
     private int y;

     public int calculateArea() {
      int area=(x*y)/2;
      return area;
     }
      public void setX(int x){
       this.x=x;
      }
      // setter/getters

     }  


package infosys.demo.withoutabstract;

    public class Rectangle {
    private int x;
    private int y;
    public int calculateArea() {
     int area=x*y;
     return area;
    }
    setter/getters
   }

package infosys.demo.withoutabstract;

   public class Display {

    public void display(Triangle t) {
    System.out.println(t.calculateArea());
    }

   public void display(Rectangle r) {
    System.out.println(r.calculateArea());
    }
  }

package infosys.demo.withoutabstract;

  public class Main  {
   public static void main(String args[]) {
      Display disp=new Display();
      Triangle triangle=new Triangle();
      Rectangle rectangle=new Rectangle();
      triangle.setX(10);
      triangle.setY(2);
      disp.display(triangle);
      rectangle.setX(20);
      rectangle.setY(10);
      disp.display(rectangle);
    }
 }
      
---------------------------------------------------------
* In Triangle and Rectangle classes we have repeated x and y and also setters and getters.
* The method calculateArea in both the classes ( Rectangle and Triangle ) are having same
  signature but implementations are different.
* We are writing overloaded form for the displayArea in Display class. So the challenge is
  when we add one more shape we have add one more method in the class Display.
------------------------------------------------------------------------------------------

package infosys.demo.withabstract;
   public class Shape {
    protected int x;
    protected int y;
   
    setters/getters;

   }

  package infosys.demo.withabstract;
  public class Rectangle extends Shape {

    public int calculateArea() {
     int area=x*y;
     return area;
    }
  }

package infosys.demo.withabstract;
  public class Triangle extends Shape {

    public int calculateArea() {
     int area=(x*y)/2;
     return area;
    }
  }


package infosys.demo.withabstract;
 public class Display {

    public void display(Shape s) {
    System.out.println(s.calculateArea());
    }

  }

package infosys.demo.withabstract;
  public class Main {
      public static void main(String str[]) {
      Display disp=new Display();
      Shape shape=null;
      Triangle triangle=new Triangle();
      triangle.setX(10);
      triangle.setY(20);
      shape=triangle; // Base class reference storing the address of the derived class object
      disp.displayArea(shape);
      Rectangle rectangle=new Rectangle();
      rectangle.setX(10);
      rectangle.setY(20);
      shape=rectangle;
      disp.displayArea(shape);
    }
  } 
   

----------------------------


package infosys.demo.withabstract;
   public abstract class Shape {
    protected int x;
    protected int y;
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}
   
   public abstract int calculateArea();
   
   }

 package infosys.demo.withabstract;
  public class Rectangle extends Shape {

    public int calculateArea() {
     int area=x*y;
     return area;
    }
  }

package infosys.demo.withabstract;
  public class Triangle extends Shape {

    public int calculateArea() {
     int area=(x*y)/2;
     return area;
    }
  }

package infosys.demo.withabstract;
 public class Display {

    public void displayArea(Shape s) {
    System.out.println(s.calculateArea());
    }

  }

package infosys.demo.withabstract;
  public class Main {
      public static void main(String str[]) {
      Display disp=new Display();
      Shape shape=null;
      Triangle triangle=new Triangle();
      triangle.setX(10);
      triangle.setY(20);
      shape=triangle; // Base class reference storing the address of the derived class object
      disp.displayArea(shape);
      Rectangle rectangle=new Rectangle();
      rectangle.setX(10);
      rectangle.setY(20);
      shape=rectangle;
      disp.displayArea(shape);
    }
  } 

-----------------------------------------------------------------------------------------------------
Interfaces provide  protocols or rules which has to be followed by the class which is implementing
the interface.

We cannot create an object of interface but we can
create a reference variable of interface and this
reference variable can hold the reference of the object of 
the class which has implmented the interface. 
// In interface we have methods which are public and abstract.


    public interface Calculator1 {
       int add(int a,int b);
       int subtract(int a, int b);
       int divide(int a, int b);
       int multiply(int a,int b);
    }

// The class which is implementing an interface needs to override all the abstract methods
// of an interface otherwise the class which is implementing the interface needs to be
// declared as an abstract class
// From java version 8 we can have interface with methods which are having body. Prior to that 
// we have interfaces where all the methods are without body which means they are abstract 
// methods. From java 8 , interface can have 3 types of method:
// 1) abstract method ( without a body)
// 2) default method ( will have body)
// 3) static method  ( will have body)

 public class Numbers1 implements Calculator1{
    public int add(int a,int b){
    return a+b;
   }
    public int subtract(int a, int b){
    return a-b;
    }
    public int divide(int a, int b){
    return a/b;
    }
    public int multiply(int a,int b){
    return a*b;
    }
   public void display(){
    System.out.println("The display method of Number1");
   }
  }
  public class Main1{
     public static void main(String args[]) {
      Calculator1 calculator=new Numbers1();
      System.out.println(calculator.add(1,2));
      System.out.println(calculator.subtract(4,2));
      System.out.println(calculator.divide(4,2));
      System.out.println(calculator.multiply(3,2));
      //calculator.display();  // We wont be able to address display method which is specific to 
      // the subclass as we dont have any declaration in the interface
      Numbers1 number=(Numbers1)calculator;
      number.display(); 
      }
 }
------------------------------------------------------------------------------------------------------
/* Interface can have variables also but those variables are public, final and static.
as they are final variables they need to be initialised at the place of declaration otherwise
we get a compilation error */

public interface CircleArea{
  float PI_VALUE=3.14f;

  float calculateArea();
}


public class Circle implements CircleArea {

  private int radius;

   // setter and getter methods

      public float calculateArea(){
       float area=PI_VALUE*radius*radius;
       return area;
      }
 }

public class Main {
   public static void main(String args[]) {
     Circle ci=new Circle();
     ci.setRadius(10);
     CircleArea ca=ci;
     System.out.println(ca.calculateArea());
    }
 } 


        

---------------------------------------------------------------------------------------------------------
// One interface can extend another interface
public interface Calculator2a{
   int add(int a,int b);
   int subtract(int a,int b);
}

public interface Calculator2b extends Calculator2a{
  int divide(int a,int b);
  int multiply(int a, int b);
}

public class Numbers2 implements Calculator2b {
     public int add(int a,int b){
    return a+b;
   }
    public int subtract(int a, int b){
    return a-b;
    }
    public int divide(int a, int b){
    return a/b;
    }
    public int multiply(int a,int b){
    return a*b;
    }
   public void display(){
    System.out.println("The display method of Number1");
   }
}

public class Main2 {
   public static void main(String args[]) {
      Calculator2b calculator=new Numbers2();
      System.out.println(calculator.add(1,2));
      System.out.println(calculator.subtract(4,2));
      System.out.println(calculator.divide(4,2));
      System.out.println(calculator.multiply(3,2));
    }
 } 

----------------------------------------------------------------------------------------------------
// One interface can extend multiple interfaces. Through this in java we undergo multiple inheritance.

public interface Calculator3a{
   int add(int a,int b);
   
}

public interface Calculator3b{
int subtract(int a,int b);
}

public interface Calculator3c{
 int multiply(int a, int b);
}
public interface Calculator3d extends Calculator3a,Calculator3b,Calculator3c{
  int divide(int a,int b);
 
}

public class Numbers3 implements Calculator3d{
   public int add(int a,int b){
    return a+b;
   }
    public int subtract(int a, int b){
    return a-b;
    }
    public int divide(int a, int b){
    return a/b;
    }
    public int multiply(int a,int b){
    return a*b;
    }
   public void display(){
    System.out.println("The display method of Number1");
   }

}
 
public class Main3 {
   public static void main(String args[]) {
     Calculator3d calculator=new Numbers3();
      System.out.println(calculator.add(1,2));
      System.out.println(calculator.subtract(4,2));
      System.out.println(calculator.divide(4,2));
      System.out.println(calculator.multiply(3,2));
   }
 }

-------------------------------------------------------------------------------------
In java a class can extend one class and can implement multiple interfaces.

  public class Base{}
  public interface Interface1{}
  public interface Interface2{}
  public interface Interface3{}
 
  public class Derived extends Base implements Interface1,Interface2,Interface3{}
---------------------------------------------------------------------------------------------------------------
 Abstract classes are extended or inherited by the class which are of similar nature and follow the hierarchy
where as interface are implemented by the class which are even not related.

 Suppose we have people from different professions like a Doctor , Teacher and a Manager all these
have a common hobby to playing instrument. 
 
 public interface Musician{
   void toPlayInstrument();
 }
 public interface Player{
   void playAGame();
 }

  public class Doctor implements Musician,Player{
    public void toMedicate(){
     System.out.println("Treat patients");
    }
    public void toPlayInstrument(){
    System.out.println("Playing flute");
    }
    public void playAGame(){
    System.out.println("Playing football");
    }
      
   
  }

  public class Teacher implements Musician {
   public void toTeach(){
    System.out.println("Teaches students");
   }
   public void toPlayInstrument(){
   System.out.println("Playing Guitar");/
   }

 }
  public class Manager implements Musician {
   public void toManage() {
    System.out.println("Manages the office");
  }

  public void toPlayInstrument(){
   System.out.println("Playing Saxaphone");
  } 
}

  public class Main{
    public static void main(String args[]) {
    Doctor doctor=new Doctor();
     Musician musician1=doctor;
     musician1.toPlayInstrument();  
     //musician1.toMedicate(); compilation error as toMedicate() method is not there in the Musician Interface 
     Doctor doctor=(Doctor)musician1;
     doctor.toMedicate();  
     Player player1=doctor;
     player1.playAGame();  
   //  player1.toPlayInstrument(); no as toPlayInstrument is not there in the Player Interface

   }
}
----------------------------------------------------------------------------------------------------
package com.infosys;
public class Hello {
	
	public void greet() {
		System.out.println("Hello Friends!!!!!!");
	}

}

package com.infosys;
// Hi is having the default access
class Hi {
  public void display() {
	  System.out.println("Hi from Hi class");
  }
}


// a class having public or default access can be 
// accessed by a class in the same package

package com.infosys;
public class HelloMain {

	public static void main(String[] args) {
		Hello hello=new Hello();
		hello.greet();
                Hi hi=new Hi();
                hi.display();
	}

}

// In the below code main method which in HelloMain is in
// different package than of Hello and Hi. Hello is 
// having public access so it is accessible in the main
// method of HelloMain which is in com.infosys2. Hi 
// is having the default access and that is the reason
// it is not accessible by the class HelloMain which is
// in a different package.

package com.infosys2;

import com.infosys.Hello;

public class HelloMain {

	public static void main(String[] args) {
	Hello hello=new Hello();
	hello.greet();
	//Hi hi=new Hi(); // As the class Hi is with the dafault access in
	// a different package. 

	}

}
-----------------------------------------------------------
We cannot declare a class as private and protected. But an inner
class can be private or protected.

We cannot write as:

 protected class Demo1{}

 private class Demo2{}

An outer class can have only public and default access.  
------------------------------------------------------------------------------------------------------
* In the same class all the members are accessible.
package com.infosys.pack1;

public class A {
	private int privateNum=10;
	int defaultNum=20;
	protected int protectedNum=30;
	public int publicNum=40;
	
	public void display()
	{
		System.out.println(privateNum);
		System.out.println(defaultNum);
		System.out.println(protectedNum);
		System.out.println(publicNum);
	}

}

*If we have a parent class and a child class in the same package, child class can access all the
members except the private member.

package com.infosys.pack1;

public class A {
	private int privateNum=10;
	int defaultNum=20;
	protected int protectedNum=30;
	public int publicNum=40;
	
	public void display()
	{
		System.out.println(privateNum);
		System.out.println(defaultNum);
		System.out.println(protectedNum);
		System.out.println(publicNum);
	}

}

package com.infosys.pack1;

public class B extends A {

	 public void disp() {
		   // System.out.println(privateNum);  private member of the base class is not accessible from the derived class
			System.out.println(defaultNum);
			System.out.println(protectedNum);
			System.out.println(publicNum); 
	 }
}

------------------------------------------------------------------------
/* If two classes are not related with Parent-Child relationship and they are in the same package,
all the members are accessible excluding the private member*/
package com.infosys.pack1;
public class A {
	private int privateNum=10;
	int defaultNum=20;
	protected int protectedNum=30;
	public int publicNum=40;
	
	public void display()
	{
		System.out.println(privateNum);
		System.out.println(defaultNum);
		System.out.println(protectedNum);
		System.out.println(publicNum);
	}

}


package com.infosys.pack1;
public class C {
	public void disp() {
		A a=new A();
		//System.out.println(a.privateNum); //The private member is not accessible
		System.out.println(a.defaultNum);
		System.out.println(a.protectedNum);
		System.out.println(a.publicNum);
		
	}
}

 --------------------------------------------------------------------------------------------------- 
/* If we have a subclass in different package, the private and default member of the Parent class
is not accessible in the subclass. */

package com.infosys.pack1;
public class A {
	private int privateNum=10;
	int defaultNum=20;
	protected int protectedNum=30;
	public int publicNum=40;
	
	public void display()
	{
		System.out.println(privateNum);
		System.out.println(defaultNum);
		System.out.println(protectedNum);
		System.out.println(publicNum);
	}

}


package com.infosys.pack2;

import com.infosys.pack1.A;

public class D extends A {
	 public void disp() {
		        //System.out.println(privateNum);
			//System.out.println(defaultNum);
			System.out.println(protectedNum);
			System.out.println(publicNum); 
	 }
}

--------------------------------------------------------------------------------------------------
/* When two classes which are not having parent child relationship and they are in different packages,
we can access only the public member of a class and rest of the members which are default or protected or private are not accessible. */
package com.infosys.pack1;
public class A {
	private int privateNum=10;
	int defaultNum=20;
	protected int protectedNum=30;
	public int publicNum=40;
	
	public void display()
	{
		System.out.println(privateNum);
		System.out.println(defaultNum);
		System.out.println(protectedNum);
		System.out.println(publicNum);
	}

}


package com.infosys.pack2;

import com.infosys.pack1.A;

public class E {

	public void disp() {
		A a=new A();
		//System.out.println(a.privateNum); 
		//System.out.println(a.defaultNum);
		//System.out.println(a.protectedNum);
		System.out.println(a.publicNum);
		
	}
}
------------------------------------------------------------------------------
So if are using package , import and class keywords , than the sequence should be 
* package
* import
* class